# 订单结算流程文档

## 概述
本文档详细记录了文智系统中订单结算的完整流程，包括订单状态管理、定时任务、佣金计算等核心功能。

## 结算状态定义

系统定义了6种结算状态：

1. **Pending** - 待处理：订单刚创建时的默认状态
2. **Eligible** - 符合结算条件：订单已定稿且金额匹配
3. **Locked** - 已锁定（有写手）：财务锁定的有写手订单
4. **SelfLocked** - 自锁定（无写手）：财务锁定的无写手订单
5. **WriterSettled** - 写手已结算：写手佣金已结算
6. **AllSettled** - 全部已结算：所有佣金已结算完成

## 核心流程

### 1. 订单录入阶段

**文件位置**: `src/controllers/customerOrder.ts` - `createCustomerOrder`函数

**流程**:
1. 客服录入订单，`settlement_status`默认为`Pending`
2. 系统自动检查是否存在需要合并的订单
3. 立即调用`checkEligibleForSettlement`检查是否符合结算条件
4. 如果符合条件（`is_fixed = 1`且金额匹配），状态自动变更为`Eligible`

### 2. 自动状态管理

**文件位置**: `src/controllers/customerOrder.ts` - `checkEligibleForSettlement`函数

**条件判断**:
- **变为Eligible**: `is_fixed = 1` 且 平台订单金额与客户录入金额差值 ≤ 0.01
- **回退到Pending**: 不满足上述条件且当前状态为`Eligible`

### 3. 定时任务系统

**文件位置**: `src/scheduler.ts`

#### 3.1 订单合并任务（每小时）
- **函数**: `scheduleCustomerOrderSync` → `autoMergeCustomerOrder`
- **功能**: 将客户订单数据合并到主订单表，同步客户ID、写手ID、费用等信息
- **触发**: 合并后自动触发佣金重新计算

#### 3.2 状态校正任务（每4小时）
- **函数**: `scheduleSettlementStatusSync` → `autoFixSettlementStatus`
- **功能**: 校正最近3天订单的`Pending` ↔ `Eligible`状态
- **范围**: 基于`is_fixed`和金额匹配条件

#### 3.3 遗漏订单检查（每日）
- **函数**: `scheduleMissedOrderCheck` → `checkEligibleForSettlement`
- **功能**: 检查并处理"遗漏"订单（客户订单已录入，平台订单后同步）

#### 3.4 佣金修复任务（每日零点）
- **函数**: `scheduleCommissionFix` → `recalculateCustomerCommissionForOrder`
- **功能**: 查找并修复符合条件但佣金为0的订单

### 4. 锁定与解锁机制

**API端点**: 
- 锁定: `/api/customer-orders/lock`
- 解锁: `/api/customer-orders/unlock`
- 状态变更: `/api/customer-orders/settlement-status`

**锁定规则**:
- 只能锁定`Eligible`状态的订单
- 有写手 → `Locked`状态
- 无写手 → `SelfLocked`状态，**立即触发佣金计算**

**解锁规则**:
- `Locked`和`SelfLocked`可解锁回`Pending`
- 解锁时客户佣金重置为0
- `WriterSettled`状态不可解锁

### 5. 佣金计算系统

**文件位置**: `src/controllers/customerOrder.ts` - `recalculateCustomerCommissionForOrder`函数

#### 5.1 计算条件
必须同时满足以下条件：
- `customer_id`不为空
- `netIncome`大于0
- `is_fixed = 1`（已定稿）
- `settlement_status`为`SelfLocked`或`WriterSettled`
- 订单在`orders`和`customer_orders`表中都存在

#### 5.2 触发时机
- 锁定到`SelfLocked`状态时
- 手动变更到`WriterSettled`状态时
- 批量合并订单后
- 全量重新计算时
- 定时任务修复时

#### 5.3 计算公式
- **无写手订单**: 固定百分比计算
- **有写手订单**: 复杂逻辑，考虑写手费用等因素

### 6. 批量操作

#### 6.1 批量佣金重算
**API端点**: `/api/orders/recalculate-commission`
**权限**: 超级管理员和财务用户
**范围**: 最近30天内符合条件的订单

#### 6.2 批量合并
**API端点**: `/api/customer-orders/merge`
**功能**: 手动触发客户订单合并

## 数据表关系

### 主要表结构
- **orders**: 主订单表，包含平台同步的订单数据
- **customer_orders**: 客户订单表，包含客服录入的订单数据

### 关键字段
- `settlement_status`: 结算状态
- `is_fixed`: 是否定稿
- `customer_id`: 客户ID
- `writer_id`: 写手ID
- `netIncome`: 净收入
- `customer_commission`: 客户佣金

## 异步处理

为避免阻塞用户操作，以下操作采用异步处理：
- 锁定后的佣金计算
- 批量合并后的佣金重算
- 定时任务中的佣金修复

## 权限控制

- **财务用户**: 可进行锁定、解锁、状态变更操作
- **主管用户**: 可进行锁定、解锁、状态变更操作
- **超级管理员**: 拥有所有权限，包括批量重算

## 日志记录

系统在关键操作点记录日志：
- 状态变更记录
- 佣金计算记录
- 错误处理记录
- 定时任务执行记录

## 潜在风险与漏洞分析

### 🔴 高风险问题

#### 1. 事务处理缺失
**问题描述**: 锁定、解锁、状态变更等关键操作缺乏数据库事务保护
**影响范围**: 可能导致数据不一致，特别是在并发操作时
**具体位置**: 
- `lockCustomerOrders` - 批量锁定时逐个更新，无事务保护
- `unlockCustomerOrders` - 同时更新两个表，无事务保护
- `updateSettlementStatus` - 批量状态更新无事务保护

**建议修复**:
```typescript
// 使用事务包装关键操作
const connection = await pool.getConnection();
await connection.beginTransaction();
try {
  // 执行多个相关操作
  await connection.commit();
} catch (error) {
  await connection.rollback();
  throw error;
} finally {
  connection.release();
}
```

#### 2. 并发竞态条件
**问题描述**: 锁定操作中存在检查-执行时间窗口，可能导致重复锁定
**影响范围**: 多用户同时操作同一订单时可能出现状态不一致
**具体位置**: `lockCustomerOrders`函数中先查询后更新的逻辑

**建议修复**: 使用数据库级别的乐观锁或悲观锁

#### 3. 佣金计算异步处理缺失
**问题描述**: 锁定到`SelfLocked`状态后应该异步触发佣金计算，但代码中未实现
**影响范围**: 用户锁定后需要手动刷新才能看到佣金
**建议修复**: 在锁定操作后异步调用佣金计算

### 🟡 中风险问题

#### 4. 定时任务错误处理不完善
**问题描述**: 定时任务中单个订单处理失败可能影响整个批次
**影响范围**: 可能导致部分订单处理失败但无明确错误记录
**建议改进**: 增加更细粒度的错误处理和重试机制

#### 5. 数据库连接池配置
**问题描述**: 连接池配置可能不足以应对高并发场景
**当前配置**: connectionLimit: 20
**建议**: 根据实际负载调整连接池大小

#### 6. 批量操作性能问题
**问题描述**: 批量锁定时使用循环逐个处理，效率较低
**建议改进**: 使用批量SQL操作提高性能

### 🟢 低风险问题

#### 7. 日志记录不够详细
**问题描述**: 关键操作的日志记录不够详细，难以追踪问题
**建议改进**: 增加操作前后的状态记录

#### 8. 权限检查重复代码
**问题描述**: 多个函数中都有相同的权限检查逻辑
**建议改进**: 抽取为中间件或工具函数

## 建议改进方案

### 短期改进（高优先级）
1. **添加事务处理**: 为所有涉及多表操作的功能添加事务保护
2. **实现异步佣金计算**: 锁定操作后异步触发佣金计算
3. **优化并发控制**: 使用数据库锁机制防止竞态条件

### 中期改进（中优先级）
1. **完善错误处理**: 增加更详细的错误日志和重试机制
2. **性能优化**: 批量操作使用批量SQL，减少数据库交互
3. **监控告警**: 添加关键操作的监控和告警机制

### 长期改进（低优先级）
1. **代码重构**: 抽取公共逻辑，减少重复代码
2. **单元测试**: 增加核心业务逻辑的单元测试
3. **文档完善**: 补充API文档和错误码说明

## 注意事项

1. **状态流转**: 严格按照定义的状态流转规则
2. **金额精度**: 金额比较使用0.01的容差
3. **并发控制**: 批量操作时注意数据一致性
4. **错误处理**: 关键操作都有完善的错误处理机制
5. **性能考虑**: 大批量操作采用分批处理
6. **⚠️ 事务处理**: 所有涉及多表操作的功能必须使用事务
7. **⚠️ 异步处理**: 耗时操作应异步执行，避免阻塞用户界面
8. **⚠️ 并发安全**: 关键业务逻辑需要考虑并发访问的安全性

---

**文档版本**: 1.1  
**最后更新**: 2024年1月  
**维护人员**: 开发团队  
**风险评估**: 已完成