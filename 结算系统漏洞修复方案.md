# 结算系统漏洞修复方案

## 概述

本文档针对订单结算系统中发现的潜在漏洞和风险点，提供具体的修复方案和代码实现建议。

## 🔴 高优先级修复方案

### 1. 事务处理修复

#### 问题分析
- `lockCustomerOrders`、`unlockCustomerOrders`、`updateSettlementStatus` 等关键函数缺乏事务保护
- 批量操作中部分成功、部分失败时会导致数据不一致

#### 修复方案

**创建事务工具函数**:
```typescript
// src/utils/transaction.ts
import { pool } from '../config/db'
import { PoolConnection } from 'mysql2/promise'

export async function withTransaction<T>(
  callback: (connection: PoolConnection) => Promise<T>
): Promise<T> {
  const connection = await pool.getConnection()
  await connection.beginTransaction()
  
  try {
    const result = await callback(connection)
    await connection.commit()
    return result
  } catch (error) {
    await connection.rollback()
    throw error
  } finally {
    connection.release()
  }
}
```

**修复 lockCustomerOrders 函数**:
```typescript
// 在 customerOrder.ts 中修改
import { withTransaction } from '../utils/transaction'

export const lockCustomerOrders = async (order_ids: number[], user: any, writer?: string) => {
  // ... 前置验证逻辑保持不变 ...
  
  return await withTransaction(async (connection) => {
    const results = []
    
    for (const orderId of validOrderIds) {
      // 使用 connection 执行查询和更新
      const [orderRows] = await connection.query(
        'SELECT * FROM customer_orders WHERE id = ? FOR UPDATE',
        [orderId]
      )
      
      if (orderRows.length === 0) continue
      
      const order = orderRows[0]
      const settlement_status = writer ? 'Locked' : 'SelfLocked'
      
      await connection.query(
        `UPDATE customer_orders SET 
         is_locked = 1, locked_by = ?, locked_at = NOW(), 
         settlement_status = ? WHERE id = ?`,
        [user.id, settlement_status, orderId]
      )
      
      // 如果是 SelfLocked，异步触发佣金计算
      if (settlement_status === 'SelfLocked') {
        // 事务提交后异步执行
        setImmediate(() => {
          recalculateCustomerCommissionForOrder(orderId).catch(console.error)
        })
      }
      
      results.push({ orderId, status: settlement_status })
    }
    
    return results
  })
}
```

**修复 unlockCustomerOrders 函数**:
```typescript
export const unlockCustomerOrders = async (order_ids: number[], user: any) => {
  // ... 前置验证逻辑保持不变 ...
  
  return await withTransaction(async (connection) => {
    const results = []
    
    for (const orderId of validOrderIds) {
      // 同时更新两个表，确保数据一致性
      await connection.query(
        `UPDATE customer_orders SET 
         is_locked = 0, locked_by = NULL, locked_at = NULL,
         settlement_status = 'Pending', customer_commission = 0
         WHERE id = ?`,
        [orderId]
      )
      
      await connection.query(
        'UPDATE orders SET customer_commission = 0 WHERE customer_order_id = ?',
        [orderId]
      )
      
      results.push({ orderId, status: 'unlocked' })
    }
    
    return results
  })
}
```

### 2. 并发竞态条件修复

#### 问题分析
- 锁定操作中存在检查-执行时间窗口
- 多用户同时操作可能导致重复锁定

#### 修复方案

**使用数据库行锁**:
```typescript
// 在事务中使用 FOR UPDATE 锁定行
const [orderRows] = await connection.query(
  `SELECT id, is_locked, settlement_status 
   FROM customer_orders 
   WHERE id IN (${order_ids.map(() => '?').join(',')}) 
   FOR UPDATE`,
  order_ids
)

// 检查锁定状态
const alreadyLocked = orderRows.filter(row => row.is_locked === 1)
if (alreadyLocked.length > 0) {
  throw new Error(`订单 ${alreadyLocked.map(r => r.id).join(', ')} 已被锁定`)
}
```

**添加乐观锁版本控制**:
```sql
-- 在 customer_orders 表中添加版本字段
ALTER TABLE customer_orders ADD COLUMN version INT DEFAULT 1;
```

```typescript
// 更新时检查版本号
const updateResult = await connection.query(
  `UPDATE customer_orders SET 
   is_locked = 1, locked_by = ?, locked_at = NOW(),
   settlement_status = ?, version = version + 1
   WHERE id = ? AND version = ?`,
  [user.id, settlement_status, orderId, currentVersion]
)

if (updateResult.affectedRows === 0) {
  throw new Error(`订单 ${orderId} 已被其他用户修改，请刷新后重试`)
}
```

### 3. 异步佣金计算实现

#### 问题分析
- 锁定到 `SelfLocked` 后应该立即计算佣金
- 当前需要用户手动刷新才能看到佣金

#### 修复方案

**创建异步任务队列**:
```typescript
// src/services/commissionQueue.ts
import { EventEmitter } from 'events'
import { recalculateCustomerCommissionForOrder } from '../controllers/customerOrder'

class CommissionQueue extends EventEmitter {
  private processing = new Set<number>()
  
  async addTask(orderId: number) {
    if (this.processing.has(orderId)) {
      console.log(`订单 ${orderId} 佣金计算任务已在队列中`)
      return
    }
    
    this.processing.add(orderId)
    
    try {
      console.log(`开始计算订单 ${orderId} 的佣金`)
      await recalculateCustomerCommissionForOrder(orderId)
      console.log(`订单 ${orderId} 佣金计算完成`)
      this.emit('completed', orderId)
    } catch (error) {
      console.error(`订单 ${orderId} 佣金计算失败:`, error)
      this.emit('failed', orderId, error)
    } finally {
      this.processing.delete(orderId)
    }
  }
  
  isProcessing(orderId: number): boolean {
    return this.processing.has(orderId)
  }
}

export const commissionQueue = new CommissionQueue()
```

**在锁定操作中集成异步计算**:
```typescript
// 在 lockCustomerOrders 中
if (settlement_status === 'SelfLocked') {
  // 事务提交后异步计算佣金
  setImmediate(() => {
    commissionQueue.addTask(orderId)
  })
}
```

## 🟡 中优先级修复方案

### 4. 定时任务错误处理优化

```typescript
// 在 scheduler.ts 中改进错误处理
export const scheduleCustomerOrderSync = () => {
  cron.schedule('0 * * * *', async () => {
    console.log('开始执行客户订单同步任务')
    const startTime = Date.now()
    let successCount = 0
    let errorCount = 0
    const errors: Array<{orderId: number, error: string}> = []
    
    try {
      const orders = await getOrdersToSync()
      
      for (const order of orders) {
        try {
          await processOrder(order)
          successCount++
        } catch (error) {
          errorCount++
          errors.push({
            orderId: order.id,
            error: error.message
          })
          console.error(`处理订单 ${order.id} 失败:`, error)
        }
      }
      
      const duration = Date.now() - startTime
      console.log(`订单同步任务完成: 成功 ${successCount}, 失败 ${errorCount}, 耗时 ${duration}ms`)
      
      if (errors.length > 0) {
        // 记录详细错误信息
        console.error('失败订单详情:', errors)
        // 可以发送告警通知
      }
      
    } catch (error) {
      console.error('订单同步任务执行失败:', error)
    }
  })
}
```

### 5. 批量操作性能优化

```typescript
// 优化批量锁定操作
export const lockCustomerOrdersBatch = async (order_ids: number[], user: any, writer?: string) => {
  return await withTransaction(async (connection) => {
    const settlement_status = writer ? 'Locked' : 'SelfLocked'
    
    // 批量检查订单状态
    const [orderRows] = await connection.query(
      `SELECT id, is_locked, settlement_status 
       FROM customer_orders 
       WHERE id IN (${order_ids.map(() => '?').join(',')}) 
       FOR UPDATE`,
      order_ids
    )
    
    // 过滤可锁定的订单
    const lockableOrders = orderRows.filter(order => 
      order.is_locked === 0 && 
      !['AllSettled', 'WriterSettled'].includes(order.settlement_status)
    )
    
    if (lockableOrders.length === 0) {
      throw new Error('没有可锁定的订单')
    }
    
    const lockableIds = lockableOrders.map(order => order.id)
    
    // 批量更新
    await connection.query(
      `UPDATE customer_orders SET 
       is_locked = 1, locked_by = ?, locked_at = NOW(),
       settlement_status = ?
       WHERE id IN (${lockableIds.map(() => '?').join(',')})`,
      [user.id, settlement_status, ...lockableIds]
    )
    
    // 异步处理佣金计算
    if (settlement_status === 'SelfLocked') {
      setImmediate(() => {
        lockableIds.forEach(orderId => {
          commissionQueue.addTask(orderId)
        })
      })
    }
    
    return {
      locked: lockableIds.length,
      orders: lockableIds
    }
  })
}
```

## 🟢 低优先级改进方案

### 6. 权限检查中间件

```typescript
// src/middleware/permission.ts
export const requireFinancialPermission = (req: any, res: any, next: any) => {
  const user = req.user
  
  if (!user || (!user.is_super_admin && user.role !== 'financial')) {
    return res.status(403).json({
      success: false,
      message: '需要财务权限或超级管理员权限'
    })
  }
  
  next()
}

export const requireSuperAdminPermission = (req: any, res: any, next: any) => {
  const user = req.user
  
  if (!user || !user.is_super_admin) {
    return res.status(403).json({
      success: false,
      message: '需要超级管理员权限'
    })
  }
  
  next()
}
```

### 7. 详细日志记录

```typescript
// src/utils/logger.ts
import winston from 'winston'

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/settlement.log' }),
    new winston.transports.Console()
  ]
})

export const logSettlementOperation = (operation: string, data: any) => {
  logger.info('Settlement Operation', {
    operation,
    timestamp: new Date().toISOString(),
    ...data
  })
}

export const logSettlementError = (operation: string, error: any, data?: any) => {
  logger.error('Settlement Error', {
    operation,
    error: error.message,
    stack: error.stack,
    timestamp: new Date().toISOString(),
    ...data
  })
}
```

## 实施建议

### 第一阶段（紧急修复）
1. 实施事务处理修复
2. 添加并发控制
3. 实现异步佣金计算

### 第二阶段（性能优化）
1. 优化批量操作
2. 完善错误处理
3. 添加监控日志

### 第三阶段（代码质量）
1. 重构公共逻辑
2. 添加单元测试
3. 完善文档

## 测试建议

### 并发测试
```javascript
// 测试并发锁定
const testConcurrentLocking = async () => {
  const orderIds = [1, 2, 3]
  const promises = []
  
  // 模拟多个用户同时锁定
  for (let i = 0; i < 5; i++) {
    promises.push(
      lockCustomerOrders(orderIds, { id: i, role: 'financial' })
    )
  }
  
  const results = await Promise.allSettled(promises)
  console.log('并发锁定测试结果:', results)
}
```

### 事务测试
```javascript
// 测试事务回滚
const testTransactionRollback = async () => {
  try {
    await withTransaction(async (connection) => {
      await connection.query('UPDATE customer_orders SET is_locked = 1 WHERE id = 1')
      throw new Error('模拟错误')
    })
  } catch (error) {
    // 验证数据是否回滚
    const [rows] = await pool.query('SELECT is_locked FROM customer_orders WHERE id = 1')
    console.log('事务回滚测试:', rows[0].is_locked === 0 ? '成功' : '失败')
  }
}
```

---

**文档版本**: 1.0  
**创建日期**: 2024年1月  
**维护人员**: 开发团队