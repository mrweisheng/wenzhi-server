# ç»“ç®—ç³»ç»Ÿæ¼æ´ä¿®å¤æ–¹æ¡ˆ

## æ¦‚è¿°

æœ¬æ–‡æ¡£é’ˆå¯¹è®¢å•ç»“ç®—ç³»ç»Ÿä¸­å‘ç°çš„æ½œåœ¨æ¼æ´å’Œé£é™©ç‚¹ï¼Œæä¾›å…·ä½“çš„ä¿®å¤æ–¹æ¡ˆå’Œä»£ç å®ç°å»ºè®®ã€‚

## ğŸ”´ é«˜ä¼˜å…ˆçº§ä¿®å¤æ–¹æ¡ˆ

### 1. äº‹åŠ¡å¤„ç†ä¿®å¤

#### é—®é¢˜åˆ†æ
- `lockCustomerOrders`ã€`unlockCustomerOrders`ã€`updateSettlementStatus` ç­‰å…³é”®å‡½æ•°ç¼ºä¹äº‹åŠ¡ä¿æŠ¤
- æ‰¹é‡æ“ä½œä¸­éƒ¨åˆ†æˆåŠŸã€éƒ¨åˆ†å¤±è´¥æ—¶ä¼šå¯¼è‡´æ•°æ®ä¸ä¸€è‡´

#### ä¿®å¤æ–¹æ¡ˆ

**åˆ›å»ºäº‹åŠ¡å·¥å…·å‡½æ•°**:
```typescript
// src/utils/transaction.ts
import { pool } from '../config/db'
import { PoolConnection } from 'mysql2/promise'

export async function withTransaction<T>(
  callback: (connection: PoolConnection) => Promise<T>
): Promise<T> {
  const connection = await pool.getConnection()
  await connection.beginTransaction()
  
  try {
    const result = await callback(connection)
    await connection.commit()
    return result
  } catch (error) {
    await connection.rollback()
    throw error
  } finally {
    connection.release()
  }
}
```

**ä¿®å¤ lockCustomerOrders å‡½æ•°**:
```typescript
// åœ¨ customerOrder.ts ä¸­ä¿®æ”¹
import { withTransaction } from '../utils/transaction'

export const lockCustomerOrders = async (order_ids: number[], user: any, writer?: string) => {
  // ... å‰ç½®éªŒè¯é€»è¾‘ä¿æŒä¸å˜ ...
  
  return await withTransaction(async (connection) => {
    const results = []
    
    for (const orderId of validOrderIds) {
      // ä½¿ç”¨ connection æ‰§è¡ŒæŸ¥è¯¢å’Œæ›´æ–°
      const [orderRows] = await connection.query(
        'SELECT * FROM customer_orders WHERE id = ? FOR UPDATE',
        [orderId]
      )
      
      if (orderRows.length === 0) continue
      
      const order = orderRows[0]
      const settlement_status = writer ? 'Locked' : 'SelfLocked'
      
      await connection.query(
        `UPDATE customer_orders SET 
         is_locked = 1, locked_by = ?, locked_at = NOW(), 
         settlement_status = ? WHERE id = ?`,
        [user.id, settlement_status, orderId]
      )
      
      // å¦‚æœæ˜¯ SelfLockedï¼Œå¼‚æ­¥è§¦å‘ä½£é‡‘è®¡ç®—
      if (settlement_status === 'SelfLocked') {
        // äº‹åŠ¡æäº¤åå¼‚æ­¥æ‰§è¡Œ
        setImmediate(() => {
          recalculateCustomerCommissionForOrder(orderId).catch(console.error)
        })
      }
      
      results.push({ orderId, status: settlement_status })
    }
    
    return results
  })
}
```

**ä¿®å¤ unlockCustomerOrders å‡½æ•°**:
```typescript
export const unlockCustomerOrders = async (order_ids: number[], user: any) => {
  // ... å‰ç½®éªŒè¯é€»è¾‘ä¿æŒä¸å˜ ...
  
  return await withTransaction(async (connection) => {
    const results = []
    
    for (const orderId of validOrderIds) {
      // åŒæ—¶æ›´æ–°ä¸¤ä¸ªè¡¨ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
      await connection.query(
        `UPDATE customer_orders SET 
         is_locked = 0, locked_by = NULL, locked_at = NULL,
         settlement_status = 'Pending', customer_commission = 0
         WHERE id = ?`,
        [orderId]
      )
      
      await connection.query(
        'UPDATE orders SET customer_commission = 0 WHERE customer_order_id = ?',
        [orderId]
      )
      
      results.push({ orderId, status: 'unlocked' })
    }
    
    return results
  })
}
```

### 2. å¹¶å‘ç«æ€æ¡ä»¶ä¿®å¤

#### é—®é¢˜åˆ†æ
- é”å®šæ“ä½œä¸­å­˜åœ¨æ£€æŸ¥-æ‰§è¡Œæ—¶é—´çª—å£
- å¤šç”¨æˆ·åŒæ—¶æ“ä½œå¯èƒ½å¯¼è‡´é‡å¤é”å®š

#### ä¿®å¤æ–¹æ¡ˆ

**ä½¿ç”¨æ•°æ®åº“è¡Œé”**:
```typescript
// åœ¨äº‹åŠ¡ä¸­ä½¿ç”¨ FOR UPDATE é”å®šè¡Œ
const [orderRows] = await connection.query(
  `SELECT id, is_locked, settlement_status 
   FROM customer_orders 
   WHERE id IN (${order_ids.map(() => '?').join(',')}) 
   FOR UPDATE`,
  order_ids
)

// æ£€æŸ¥é”å®šçŠ¶æ€
const alreadyLocked = orderRows.filter(row => row.is_locked === 1)
if (alreadyLocked.length > 0) {
  throw new Error(`è®¢å• ${alreadyLocked.map(r => r.id).join(', ')} å·²è¢«é”å®š`)
}
```

**æ·»åŠ ä¹è§‚é”ç‰ˆæœ¬æ§åˆ¶**:
```sql
-- åœ¨ customer_orders è¡¨ä¸­æ·»åŠ ç‰ˆæœ¬å­—æ®µ
ALTER TABLE customer_orders ADD COLUMN version INT DEFAULT 1;
```

```typescript
// æ›´æ–°æ—¶æ£€æŸ¥ç‰ˆæœ¬å·
const updateResult = await connection.query(
  `UPDATE customer_orders SET 
   is_locked = 1, locked_by = ?, locked_at = NOW(),
   settlement_status = ?, version = version + 1
   WHERE id = ? AND version = ?`,
  [user.id, settlement_status, orderId, currentVersion]
)

if (updateResult.affectedRows === 0) {
  throw new Error(`è®¢å• ${orderId} å·²è¢«å…¶ä»–ç”¨æˆ·ä¿®æ”¹ï¼Œè¯·åˆ·æ–°åé‡è¯•`)
}
```

### 3. å¼‚æ­¥ä½£é‡‘è®¡ç®—å®ç°

#### é—®é¢˜åˆ†æ
- é”å®šåˆ° `SelfLocked` ååº”è¯¥ç«‹å³è®¡ç®—ä½£é‡‘
- å½“å‰éœ€è¦ç”¨æˆ·æ‰‹åŠ¨åˆ·æ–°æ‰èƒ½çœ‹åˆ°ä½£é‡‘

#### ä¿®å¤æ–¹æ¡ˆ

**åˆ›å»ºå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—**:
```typescript
// src/services/commissionQueue.ts
import { EventEmitter } from 'events'
import { recalculateCustomerCommissionForOrder } from '../controllers/customerOrder'

class CommissionQueue extends EventEmitter {
  private processing = new Set<number>()
  
  async addTask(orderId: number) {
    if (this.processing.has(orderId)) {
      console.log(`è®¢å• ${orderId} ä½£é‡‘è®¡ç®—ä»»åŠ¡å·²åœ¨é˜Ÿåˆ—ä¸­`)
      return
    }
    
    this.processing.add(orderId)
    
    try {
      console.log(`å¼€å§‹è®¡ç®—è®¢å• ${orderId} çš„ä½£é‡‘`)
      await recalculateCustomerCommissionForOrder(orderId)
      console.log(`è®¢å• ${orderId} ä½£é‡‘è®¡ç®—å®Œæˆ`)
      this.emit('completed', orderId)
    } catch (error) {
      console.error(`è®¢å• ${orderId} ä½£é‡‘è®¡ç®—å¤±è´¥:`, error)
      this.emit('failed', orderId, error)
    } finally {
      this.processing.delete(orderId)
    }
  }
  
  isProcessing(orderId: number): boolean {
    return this.processing.has(orderId)
  }
}

export const commissionQueue = new CommissionQueue()
```

**åœ¨é”å®šæ“ä½œä¸­é›†æˆå¼‚æ­¥è®¡ç®—**:
```typescript
// åœ¨ lockCustomerOrders ä¸­
if (settlement_status === 'SelfLocked') {
  // äº‹åŠ¡æäº¤åå¼‚æ­¥è®¡ç®—ä½£é‡‘
  setImmediate(() => {
    commissionQueue.addTask(orderId)
  })
}
```

## ğŸŸ¡ ä¸­ä¼˜å…ˆçº§ä¿®å¤æ–¹æ¡ˆ

### 4. å®šæ—¶ä»»åŠ¡é”™è¯¯å¤„ç†ä¼˜åŒ–

```typescript
// åœ¨ scheduler.ts ä¸­æ”¹è¿›é”™è¯¯å¤„ç†
export const scheduleCustomerOrderSync = () => {
  cron.schedule('0 * * * *', async () => {
    console.log('å¼€å§‹æ‰§è¡Œå®¢æˆ·è®¢å•åŒæ­¥ä»»åŠ¡')
    const startTime = Date.now()
    let successCount = 0
    let errorCount = 0
    const errors: Array<{orderId: number, error: string}> = []
    
    try {
      const orders = await getOrdersToSync()
      
      for (const order of orders) {
        try {
          await processOrder(order)
          successCount++
        } catch (error) {
          errorCount++
          errors.push({
            orderId: order.id,
            error: error.message
          })
          console.error(`å¤„ç†è®¢å• ${order.id} å¤±è´¥:`, error)
        }
      }
      
      const duration = Date.now() - startTime
      console.log(`è®¢å•åŒæ­¥ä»»åŠ¡å®Œæˆ: æˆåŠŸ ${successCount}, å¤±è´¥ ${errorCount}, è€—æ—¶ ${duration}ms`)
      
      if (errors.length > 0) {
        // è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯
        console.error('å¤±è´¥è®¢å•è¯¦æƒ…:', errors)
        // å¯ä»¥å‘é€å‘Šè­¦é€šçŸ¥
      }
      
    } catch (error) {
      console.error('è®¢å•åŒæ­¥ä»»åŠ¡æ‰§è¡Œå¤±è´¥:', error)
    }
  })
}
```

### 5. æ‰¹é‡æ“ä½œæ€§èƒ½ä¼˜åŒ–

```typescript
// ä¼˜åŒ–æ‰¹é‡é”å®šæ“ä½œ
export const lockCustomerOrdersBatch = async (order_ids: number[], user: any, writer?: string) => {
  return await withTransaction(async (connection) => {
    const settlement_status = writer ? 'Locked' : 'SelfLocked'
    
    // æ‰¹é‡æ£€æŸ¥è®¢å•çŠ¶æ€
    const [orderRows] = await connection.query(
      `SELECT id, is_locked, settlement_status 
       FROM customer_orders 
       WHERE id IN (${order_ids.map(() => '?').join(',')}) 
       FOR UPDATE`,
      order_ids
    )
    
    // è¿‡æ»¤å¯é”å®šçš„è®¢å•
    const lockableOrders = orderRows.filter(order => 
      order.is_locked === 0 && 
      !['AllSettled', 'WriterSettled'].includes(order.settlement_status)
    )
    
    if (lockableOrders.length === 0) {
      throw new Error('æ²¡æœ‰å¯é”å®šçš„è®¢å•')
    }
    
    const lockableIds = lockableOrders.map(order => order.id)
    
    // æ‰¹é‡æ›´æ–°
    await connection.query(
      `UPDATE customer_orders SET 
       is_locked = 1, locked_by = ?, locked_at = NOW(),
       settlement_status = ?
       WHERE id IN (${lockableIds.map(() => '?').join(',')})`,
      [user.id, settlement_status, ...lockableIds]
    )
    
    // å¼‚æ­¥å¤„ç†ä½£é‡‘è®¡ç®—
    if (settlement_status === 'SelfLocked') {
      setImmediate(() => {
        lockableIds.forEach(orderId => {
          commissionQueue.addTask(orderId)
        })
      })
    }
    
    return {
      locked: lockableIds.length,
      orders: lockableIds
    }
  })
}
```

## ğŸŸ¢ ä½ä¼˜å…ˆçº§æ”¹è¿›æ–¹æ¡ˆ

### 6. æƒé™æ£€æŸ¥ä¸­é—´ä»¶

```typescript
// src/middleware/permission.ts
export const requireFinancialPermission = (req: any, res: any, next: any) => {
  const user = req.user
  
  if (!user || (!user.is_super_admin && user.role !== 'financial')) {
    return res.status(403).json({
      success: false,
      message: 'éœ€è¦è´¢åŠ¡æƒé™æˆ–è¶…çº§ç®¡ç†å‘˜æƒé™'
    })
  }
  
  next()
}

export const requireSuperAdminPermission = (req: any, res: any, next: any) => {
  const user = req.user
  
  if (!user || !user.is_super_admin) {
    return res.status(403).json({
      success: false,
      message: 'éœ€è¦è¶…çº§ç®¡ç†å‘˜æƒé™'
    })
  }
  
  next()
}
```

### 7. è¯¦ç»†æ—¥å¿—è®°å½•

```typescript
// src/utils/logger.ts
import winston from 'winston'

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/settlement.log' }),
    new winston.transports.Console()
  ]
})

export const logSettlementOperation = (operation: string, data: any) => {
  logger.info('Settlement Operation', {
    operation,
    timestamp: new Date().toISOString(),
    ...data
  })
}

export const logSettlementError = (operation: string, error: any, data?: any) => {
  logger.error('Settlement Error', {
    operation,
    error: error.message,
    stack: error.stack,
    timestamp: new Date().toISOString(),
    ...data
  })
}
```

## å®æ–½å»ºè®®

### ç¬¬ä¸€é˜¶æ®µï¼ˆç´§æ€¥ä¿®å¤ï¼‰
1. å®æ–½äº‹åŠ¡å¤„ç†ä¿®å¤
2. æ·»åŠ å¹¶å‘æ§åˆ¶
3. å®ç°å¼‚æ­¥ä½£é‡‘è®¡ç®—

### ç¬¬äºŒé˜¶æ®µï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
1. ä¼˜åŒ–æ‰¹é‡æ“ä½œ
2. å®Œå–„é”™è¯¯å¤„ç†
3. æ·»åŠ ç›‘æ§æ—¥å¿—

### ç¬¬ä¸‰é˜¶æ®µï¼ˆä»£ç è´¨é‡ï¼‰
1. é‡æ„å…¬å…±é€»è¾‘
2. æ·»åŠ å•å…ƒæµ‹è¯•
3. å®Œå–„æ–‡æ¡£

## æµ‹è¯•å»ºè®®

### å¹¶å‘æµ‹è¯•
```javascript
// æµ‹è¯•å¹¶å‘é”å®š
const testConcurrentLocking = async () => {
  const orderIds = [1, 2, 3]
  const promises = []
  
  // æ¨¡æ‹Ÿå¤šä¸ªç”¨æˆ·åŒæ—¶é”å®š
  for (let i = 0; i < 5; i++) {
    promises.push(
      lockCustomerOrders(orderIds, { id: i, role: 'financial' })
    )
  }
  
  const results = await Promise.allSettled(promises)
  console.log('å¹¶å‘é”å®šæµ‹è¯•ç»“æœ:', results)
}
```

### äº‹åŠ¡æµ‹è¯•
```javascript
// æµ‹è¯•äº‹åŠ¡å›æ»š
const testTransactionRollback = async () => {
  try {
    await withTransaction(async (connection) => {
      await connection.query('UPDATE customer_orders SET is_locked = 1 WHERE id = 1')
      throw new Error('æ¨¡æ‹Ÿé”™è¯¯')
    })
  } catch (error) {
    // éªŒè¯æ•°æ®æ˜¯å¦å›æ»š
    const [rows] = await pool.query('SELECT is_locked FROM customer_orders WHERE id = 1')
    console.log('äº‹åŠ¡å›æ»šæµ‹è¯•:', rows[0].is_locked === 0 ? 'æˆåŠŸ' : 'å¤±è´¥')
  }
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¥æœŸ**: 2024å¹´1æœˆ  
**ç»´æŠ¤äººå‘˜**: å¼€å‘å›¢é˜Ÿ